import json
import textwrap

import pytest
from pyarn import lockfile

from cachi2.core.errors import PackageRejected
from cachi2.core.package_managers.yarn_classic.project import PackageJson, YarnLock, YarnRc
from cachi2.core.rooted_path import RootedPath

VALID_YARNRC_FILE = """
yarn-path "/usr/bin/yarn"
--cache-folder /tmp/yarn-cache/
"""

INVALID_YARNRC = "totally not yarnrc"

EMPTY_YARNRC_FILE = ""


VALID_PACKAGE_JSON_FILE = """
{
  "name": "camelot",
  "packageManager": "yarn@3.6.1"
}
"""

EMPTY_JSON_FILE = "{}"

INVALID_JSON = "totally not json"

VALID_YARN_LOCK_FILE = """
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1
package-1@^1.0.0:
  version "1.0.3"
  resolved "https://registry.npmjs.org/package-1/-/package-1-1.0.3.tgz#a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0"
"""

EMPTY_YARN_LOCK_FILE = ""

# The version line (`yarn lockfile v1`) is required
INVALID_YARN_LOCK_FILE = """
package-1@^1.0.0:
  version "1.0.3"
  resolved "https://registry.npmjs.org/package-1/-/package-1-1.0.3.tgz#a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0"
"""


def _prepare_config_file(
    rooted_tmp_path: RootedPath, file_class, filename: str, data: str
) -> PackageJson:
    path = rooted_tmp_path.join_within_root(filename)

    with open(path, "w") as f:
        f.write(data)

    return file_class.from_file(path)


@pytest.mark.parametrize(
    "config_file_class, config_file_name, config_file_content, content_type",
    [
        pytest.param(
            PackageJson, "package.json", VALID_PACKAGE_JSON_FILE, "json", id="package_json"
        ),
        pytest.param(YarnRc, ".yarnrc", VALID_YARNRC_FILE, "yarnrc", id="yarnrc"),
        pytest.param(YarnLock, "yarn.lock", VALID_YARN_LOCK_FILE, "pyarn", id="yarnlock"),
    ],
)
def test_find_and_open_config(
    rooted_tmp_path: RootedPath,
    config_file_class,
    config_file_name: str,
    config_file_content: str,
    content_type: str,
) -> None:
    found_config = _prepare_config_file(
        rooted_tmp_path, config_file_class, config_file_name, config_file_content
    )

    if content_type == "json":
        assert found_config.data == json.loads(config_file_content)
    elif content_type == "pyarn":
        assert found_config.data == lockfile.Lockfile.from_str(config_file_content).data
    elif content_type == "yarnrc":
        assert found_config.data == YarnRc.from_str(config_file_content)


# rooted_tmp_path, file_class, filename, data
def test_parse_yarnrc(rooted_tmp_path: RootedPath) -> None:
    yarn_rc = _prepare_config_file(rooted_tmp_path, YarnRc, ".yarnrc", VALID_YARNRC_FILE)
    assert yarn_rc.data["yarn-path"] == '"/usr/bin/yarn"'


def test_parse_empty_yarnrc(rooted_tmp_path: RootedPath) -> None:
    yarn_rc = _prepare_config_file(rooted_tmp_path, YarnRc, ".yarnrc", EMPTY_YARNRC_FILE)
    assert yarn_rc.data["yarn-path"] is None


def test_parse_invalid_yarnrc(rooted_tmp_path: RootedPath) -> None:
    with pytest.raises(PackageRejected, match="Can't parse the .yarnrc file"):
        _prepare_config_file(rooted_tmp_path, YarnRc, ".yarnrc", INVALID_YARNRC)


def test_write_yarnrc(rooted_tmp_path: RootedPath) -> None:
    data = {
        "cacheFolder": ".cache/folder",
        "plugins": {
            "path": ".path/to/plugin",
            "spec": "@yarnpkg/nice-plugin",
        },
    }

    expected_yaml = textwrap.dedent(
        """
        cacheFolder: .cache/folder
        plugins:
          path: .path/to/plugin
          spec: '@yarnpkg/nice-plugin'
        """
    ).lstrip()

    file_path = rooted_tmp_path.join_within_root(".yarnrc.yml")

    yarn_rc = YarnRc(file_path, data)
    yarn_rc.write()

    with open(file_path, "r") as f:
        actual_yaml = f.read()

    assert actual_yaml == expected_yaml


# @pytest.mark.parametrize(
#     "is_pnp_install, nodeLinker",
#     [
#         pytest.param(True, "pnp", id="nodeLinker-pnp"),
#         pytest.param(True, "node-modules", id="nodeLinker-node-modules"),
#         pytest.param(True, "", id="pnp-empty-use-default"),
#         pytest.param(False, "", id="regular-workflow"),
#     ],
# )
# def test_pnp_installs_detection(
#     rooted_tmp_path: RootedPath, is_pnp_install: bool, nodeLinker: str
# ) -> None:
#     _prepare_package_json_file(rooted_tmp_path, VALID_PACKAGE_JSON_FILE)
#     project = Project.from_source_dir(rooted_tmp_path)

#     if is_pnp_install:
#         _check_pnp_installs(nodeLinker, rooted_tmp_path)
#     assert project.is_pnp_install is is_pnp_install
